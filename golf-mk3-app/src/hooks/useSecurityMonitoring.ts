import { useState, useEffect, useCallback } from 'react';\nimport SecurityMonitoringService, {\n  SecurityMetrics,\n  SecurityAlert,\n  SecurityEvent,\n} from '../services/SecurityMonitoringService';\n\ninterface UseSecurityMonitoringOptions {\n  autoRefresh?: boolean;\n  refreshInterval?: number;\n  onAlert?: (alert: SecurityAlert) => void;\n  onCriticalEvent?: (event: SecurityEvent) => void;\n}\n\nexport const useSecurityMonitoring = (options: UseSecurityMonitoringOptions = {}) => {\n  const {\n    autoRefresh = true,\n    refreshInterval = 30000, // 30 segundos\n    onAlert,\n    onCriticalEvent,\n  } = options;\n\n  const [metrics, setMetrics] = useState<SecurityMetrics | null>(null);\n  const [alerts, setAlerts] = useState<SecurityAlert[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [lastUpdate, setLastUpdate] = useState<Date | null>(null);\n\n  // Carregar dados de segurança\n  const loadSecurityData = useCallback(async () => {\n    try {\n      setIsLoading(true);\n      \n      const securityMetrics = SecurityMonitoringService.getSecurityMetrics();\n      const activeAlerts = SecurityMonitoringService.getActiveAlerts();\n      \n      setMetrics(securityMetrics);\n      setAlerts(activeAlerts);\n      setLastUpdate(new Date());\n      \n      // Verificar novos alertas críticos\n      const criticalAlerts = activeAlerts.filter(alert => alert.severity === 'critical');\n      criticalAlerts.forEach(alert => {\n        if (onAlert) {\n          onAlert(alert);\n        }\n      });\n      \n    } catch (error) {\n      console.error('Failed to load security data:', error);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [onAlert]);\n\n  // Registrar evento de segurança\n  const logSecurityEvent = useCallback(async (\n    type: SecurityEvent['type'],\n    details: any,\n    severity: SecurityEvent['severity'] = 'medium'\n  ) => {\n    try {\n      const eventId = await SecurityMonitoringService.logSecurityEvent(type, details, severity);\n      \n      // Recarregar dados após registrar evento\n      await loadSecurityData();\n      \n      // Callback para eventos críticos\n      if (severity === 'critical' && onCriticalEvent) {\n        const event: SecurityEvent = {\n          id: eventId,\n          type,\n          timestamp: new Date().toISOString(),\n          severity,\n          details,\n          resolved: false,\n        };\n        onCriticalEvent(event);\n      }\n      \n      return eventId;\n    } catch (error) {\n      console.error('Failed to log security event:', error);\n      throw error;\n    }\n  }, [loadSecurityData, onCriticalEvent]);\n\n  // Reconhecer alerta\n  const acknowledgeAlert = useCallback(async (alertId: string) => {\n    try {\n      const success = await SecurityMonitoringService.acknowledgeAlert(alertId);\n      if (success) {\n        await loadSecurityData();\n      }\n      return success;\n    } catch (error) {\n      console.error('Failed to acknowledge alert:', error);\n      return false;\n    }\n  }, [loadSecurityData]);\n\n  // Resolver evento\n  const resolveEvent = useCallback(async (eventId: string) => {\n    try {\n      const success = await SecurityMonitoringService.resolveEvent(eventId);\n      if (success) {\n        await loadSecurityData();\n      }\n      return success;\n    } catch (error) {\n      console.error('Failed to resolve event:', error);\n      return false;\n    }\n  }, [loadSecurityData]);\n\n  // Gerar relatório\n  const generateReport = useCallback(() => {\n    return SecurityMonitoringService.generateSecurityReport();\n  }, []);\n\n  // Exportar dados\n  const exportData = useCallback(() => {\n    return SecurityMonitoringService.exportSecurityData();\n  }, []);\n\n  // Limpar dados antigos\n  const cleanupOldData = useCallback(async (daysToKeep: number = 30) => {\n    try {\n      const removedCount = await SecurityMonitoringService.cleanupOldData(daysToKeep);\n      await loadSecurityData();\n      return removedCount;\n    } catch (error) {\n      console.error('Failed to cleanup old data:', error);\n      return 0;\n    }\n  }, [loadSecurityData]);\n\n  // Verificar status de segurança\n  const getSecurityStatus = useCallback(() => {\n    if (!metrics) return 'unknown';\n    \n    const criticalAlerts = alerts.filter(alert => alert.severity === 'critical').length;\n    const highAlerts = alerts.filter(alert => alert.severity === 'high').length;\n    \n    if (criticalAlerts > 0) return 'critical';\n    if (highAlerts > 0 || metrics.violationRate > 10) return 'warning';\n    if (metrics.protectionEffectiveness < 80) return 'caution';\n    return 'good';\n  }, [metrics, alerts]);\n\n  // Obter estatísticas resumidas\n  const getSecuritySummary = useCallback(() => {\n    if (!metrics) return null;\n    \n    return {\n      status: getSecurityStatus(),\n      totalEvents: metrics.totalEvents,\n      activeAlerts: alerts.length,\n      criticalAlerts: alerts.filter(alert => alert.severity === 'critical').length,\n      effectiveness: metrics.protectionEffectiveness,\n      violationRate: metrics.violationRate,\n      lastUpdate,\n    };\n  }, [metrics, alerts, getSecurityStatus, lastUpdate]);\n\n  // Configurar auto-refresh\n  useEffect(() => {\n    loadSecurityData();\n    \n    if (autoRefresh) {\n      const interval = setInterval(loadSecurityData, refreshInterval);\n      return () => clearInterval(interval);\n    }\n  }, [loadSecurityData, autoRefresh, refreshInterval]);\n\n  return {\n    // Estado\n    metrics,\n    alerts,\n    isLoading,\n    lastUpdate,\n    \n    // Ações\n    loadSecurityData,\n    logSecurityEvent,\n    acknowledgeAlert,\n    resolveEvent,\n    generateReport,\n    exportData,\n    cleanupOldData,\n    \n    // Utilitários\n    getSecurityStatus,\n    getSecuritySummary,\n  };\n};\n\n// Hook para monitoramento específico de screenshots\nexport const useScreenshotMonitoring = () => {\n  const { logSecurityEvent } = useSecurityMonitoring();\n  \n  const logScreenshotAttempt = useCallback(async (details: any = {}) => {\n    return await logSecurityEvent('screenshot_attempt', {\n      ...details,\n      timestamp: new Date().toISOString(),\n      userAgent: navigator.userAgent,\n    }, 'medium');\n  }, [logSecurityEvent]);\n  \n  const logRecordingAttempt = useCallback(async (details: any = {}) => {\n    return await logSecurityEvent('recording_attempt', {\n      ...details,\n      timestamp: new Date().toISOString(),\n      userAgent: navigator.userAgent,\n    }, 'high');\n  }, [logSecurityEvent]);\n  \n  return {\n    logScreenshotAttempt,\n    logRecordingAttempt,\n  };\n};\n\n// Hook para monitoramento de acesso não autorizado\nexport const useAccessMonitoring = () => {\n  const { logSecurityEvent } = useSecurityMonitoring();\n  \n  const logUnauthorizedAccess = useCallback(async (details: any = {}) => {\n    return await logSecurityEvent('unauthorized_access', {\n      ...details,\n      timestamp: new Date().toISOString(),\n      location: window.location.href,\n    }, 'high');\n  }, [logSecurityEvent]);\n  \n  const logDataExtraction = useCallback(async (details: any = {}) => {\n    return await logSecurityEvent('data_extraction', {\n      ...details,\n      timestamp: new Date().toISOString(),\n      location: window.location.href,\n    }, 'critical');\n  }, [logSecurityEvent]);\n  \n  return {\n    logUnauthorizedAccess,\n    logDataExtraction,\n  };\n};\n\n// Hook para alertas em tempo real\nexport const useSecurityAlerts = (options: {\n  onCriticalAlert?: (alert: SecurityAlert) => void;\n  onHighAlert?: (alert: SecurityAlert) => void;\n  showNotifications?: boolean;\n} = {}) => {\n  const { onCriticalAlert, onHighAlert, showNotifications = true } = options;\n  const [recentAlerts, setRecentAlerts] = useState<SecurityAlert[]>([]);\n  \n  const { alerts } = useSecurityMonitoring({\n    onAlert: (alert) => {\n      // Adicionar à lista de alertas recentes\n      setRecentAlerts(prev => [alert, ...prev.slice(0, 9)]);\n      \n      // Callbacks específicos por severidade\n      if (alert.severity === 'critical' && onCriticalAlert) {\n        onCriticalAlert(alert);\n      } else if (alert.severity === 'high' && onHighAlert) {\n        onHighAlert(alert);\n      }\n      \n      // Mostrar notificação se habilitado\n      if (showNotifications && typeof window !== 'undefined' && 'Notification' in window) {\n        if (Notification.permission === 'granted') {\n          new Notification(`Alerta de Segurança - ${alert.severity.toUpperCase()}`, {\n            body: alert.message,\n            icon: '/favicon.png',\n            tag: alert.id,\n          });\n        }\n      }\n    },\n  });\n  \n  // Solicitar permissão para notificações\n  const requestNotificationPermission = useCallback(async () => {\n    if (typeof window !== 'undefined' && 'Notification' in window) {\n      if (Notification.permission === 'default') {\n        const permission = await Notification.requestPermission();\n        return permission === 'granted';\n      }\n      return Notification.permission === 'granted';\n    }\n    return false;\n  }, []);\n  \n  return {\n    alerts,\n    recentAlerts,\n    requestNotificationPermission,\n  };\n};\n\n// Hook para métricas de performance de segurança\nexport const useSecurityPerformance = () => {\n  const { metrics } = useSecurityMonitoring();\n  const [performanceHistory, setPerformanceHistory] = useState<{\n    timestamp: string;\n    effectiveness: number;\n    violationRate: number;\n  }[]>([]);\n  \n  // Registrar métricas históricas\n  useEffect(() => {\n    if (metrics) {\n      setPerformanceHistory(prev => [\n        {\n          timestamp: new Date().toISOString(),\n          effectiveness: metrics.protectionEffectiveness,\n          violationRate: metrics.violationRate,\n        },\n        ...prev.slice(0, 99), // Manter últimas 100 entradas\n      ]);\n    }\n  }, [metrics]);\n  \n  const getPerformanceTrend = useCallback(() => {\n    if (performanceHistory.length < 2) return 'stable';\n    \n    const recent = performanceHistory.slice(0, 5);\n    const older = performanceHistory.slice(5, 10);\n    \n    if (recent.length === 0 || older.length === 0) return 'stable';\n    \n    const recentAvg = recent.reduce((sum, item) => sum + item.effectiveness, 0) / recent.length;\n    const olderAvg = older.reduce((sum, item) => sum + item.effectiveness, 0) / older.length;\n    \n    const diff = recentAvg - olderAvg;\n    \n    if (Math.abs(diff) < 2) return 'stable';\n    return diff > 0 ? 'improving' : 'declining';\n  }, [performanceHistory]);\n  \n  return {\n    metrics,\n    performanceHistory,\n    getPerformanceTrend,\n  };\n};\n\nexport default useSecurityMonitoring;"} 
ToolResult: SUCCESS - Created the golf-mk3-app/src/hooks/useSecurityMonitoring.ts file. 
<function_calls>
<invoke name="taskStatus">
<parameter name="taskFilePath">.kiro/specs/golf-mk3-app/tasks.md