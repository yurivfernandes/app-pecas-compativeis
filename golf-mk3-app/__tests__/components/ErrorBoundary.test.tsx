import React from 'react'; \nimport { render, fireEvent, waitFor } from '@testing-library/react-native'; \nimport { Text, View } from 'react-native'; \nimport ErrorBoundary, { useErrorHandler } from '../../src/components/common/ErrorBoundary'; \nimport { AnalyticsService } from '../../src/services/AnalyticsService'; \nimport { ErrorService } from '../../src/services/ErrorService'; \n\n// Mock dependencies\njest.mock('../../src/services/AnalyticsService');\njest.mock('../../src/services/ErrorService');\njest.mock('@expo/vector-icons', () => ({\n  Ionicons: 'Ionicons',\n}));\n\n// Mock console.error to avoid noise in tests\nconst originalConsoleError = console.error;\nbeforeAll(() => {\n  console.error = jest.fn();\n});\n\nafterAll(() => {\n  console.error = originalConsoleError;\n});\n\n// Component that throws an error\nconst ThrowError = ({ shouldThrow = false, errorMessage = 'Test error' }) => {\n  if (shouldThrow) {\n    throw new Error(errorMessage);\n  }\n  return <Text>No error</Text>;\n};\n\n// Component that uses error handler hook\nconst ComponentWithErrorHandler = ({ shouldTriggerError = false }) => {\n  const { handleError } = useErrorHandler();\n\n  const triggerError = () => {\n    handleError(new Error('Manual error'), { context: 'test' });\n  };\n\n  return (\n    <View>\n      <Text>Component with error handler</Text>\n      {shouldTriggerError && (\n        <Text onPress={triggerError}>Trigger Error</Text>\n      )}\n    </View>\n  );\n};\n\ndescribe('ErrorBoundary', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  it('should render children when there is no error', () => {\n    const { getByText } = render(\n      <ErrorBoundary>\n        <Text>Test content</Text>\n      </ErrorBoundary>\n    );\n\n    expect(getByText('Test content')).toBeTruthy();\n  });\n\n  it('should render error UI when child component throws', async () => {\n    const { getByText, rerender } = render(\n      <ErrorBoundary>\n        <ThrowError shouldThrow={false} />\n      </ErrorBoundary>\n    );\n\n    expect(getByText('No error')).toBeTruthy();\n\n    // Trigger error\n    rerender(\n      <ErrorBoundary>\n        <ThrowError shouldThrow={true} />\n      </ErrorBoundary>\n    );\n\n    await waitFor(() => {\n      expect(getByText('Ops! Algo deu errado')).toBeTruthy();\n      expect(getByText('Encontramos um problema inesperado. Não se preocupe, você pode tentar novamente.')).toBeTruthy();\n    });\n  });\n\n  it('should call analytics service when error occurs', async () => {\n    const { rerender } = render(\n      <ErrorBoundary>\n        <ThrowError shouldThrow={false} />\n      </ErrorBoundary>\n    );\n\n    rerender(\n      <ErrorBoundary>\n        <ThrowError shouldThrow={true} errorMessage=\"Analytics test error\" />\n      </ErrorBoundary>\n    );\n\n    await waitFor(() => {\n      expect(AnalyticsService.trackError).toHaveBeenCalledWith(\n        'Error',\n        'Analytics test error',\n        expect.objectContaining({\n          stack: expect.any(String),\n          componentStack: expect.any(String),\n          errorId: expect.any(String),\n        })\n      );\n    });\n  });\n\n  it('should call error service when error occurs', async () => {\n    const { rerender } = render(\n      <ErrorBoundary>\n        <ThrowError shouldThrow={false} />\n      </ErrorBoundary>\n    );\n\n    rerender(\n      <ErrorBoundary>\n        <ThrowError shouldThrow={true} errorMessage=\"Service test error\" />\n      </ErrorBoundary>\n    );\n\n    await waitFor(() => {\n      expect(ErrorService.logError).toHaveBeenCalledWith(\n        expect.objectContaining({\n          type: 'component_error',\n          message: 'Service test error',\n          stack: expect.any(String),\n          componentStack: expect.any(String),\n          errorId: expect.any(String),\n          timestamp: expect.any(String),\n        })\n      );\n    });\n  });\n\n  it('should call custom onError callback', async () => {\n    const onErrorMock = jest.fn();\n    const { rerender } = render(\n      <ErrorBoundary onError={onErrorMock}>\n        <ThrowError shouldThrow={false} />\n      </ErrorBoundary>\n    );\n\n    rerender(\n      <ErrorBoundary onError={onErrorMock}>\n        <ThrowError shouldThrow={true} errorMessage=\"Callback test error\" />\n      </ErrorBoundary>\n    );\n\n    await waitFor(() => {\n      expect(onErrorMock).toHaveBeenCalledWith(\n        expect.objectContaining({ message: 'Callback test error' }),\n        expect.any(Object)\n      );\n    });\n  });\n\n  it('should render custom fallback UI', async () => {\n    const customFallback = <Text>Custom error message</Text>;\n    \n    const { getByText, rerender } = render(\n      <ErrorBoundary fallback={customFallback}>\n        <ThrowError shouldThrow={false} />\n      </ErrorBoundary>\n    );\n\n    rerender(\n      <ErrorBoundary fallback={customFallback}>\n        <ThrowError shouldThrow={true} />\n      </ErrorBoundary>\n    );\n\n    await waitFor(() => {\n      expect(getByText('Custom error message')).toBeTruthy();\n    });\n  });\n\n  it('should handle retry button press', async () => {\n    const { getByText, rerender } = render(\n      <ErrorBoundary>\n        <ThrowError shouldThrow={false} />\n      </ErrorBoundary>\n    );\n\n    // Trigger error\n    rerender(\n      <ErrorBoundary>\n        <ThrowError shouldThrow={true} />\n      </ErrorBoundary>\n    );\n\n    await waitFor(() => {\n      expect(getByText('Ops! Algo deu errado')).toBeTruthy();\n    });\n\n    // Press retry button\n    fireEvent.press(getByText('Tentar Novamente'));\n\n    await waitFor(() => {\n      expect(AnalyticsService.trackEvent).toHaveBeenCalledWith(\n        'error_boundary_retry',\n        expect.objectContaining({\n          errorId: expect.any(String),\n          errorType: 'Error',\n        })\n      );\n    });\n  });\n\n  it('should handle reload button press', async () => {\n    // Mock window.location.reload\n    const mockReload = jest.fn();\n    Object.defineProperty(window, 'location', {\n      value: { reload: mockReload },\n      writable: true,\n    });\n\n    const { getByText, rerender } = render(\n      <ErrorBoundary>\n        <ThrowError shouldThrow={false} />\n      </ErrorBoundary>\n    );\n\n    // Trigger error\n    rerender(\n      <ErrorBoundary>\n        <ThrowError shouldThrow={true} />\n      </ErrorBoundary>\n    );\n\n    await waitFor(() => {\n      expect(getByText('Ops! Algo deu errado')).toBeTruthy();\n    });\n\n    // Press reload button\n    fireEvent.press(getByText('Recarregar App'));\n\n    await waitFor(() => {\n      expect(AnalyticsService.trackEvent).toHaveBeenCalledWith(\n        'error_boundary_reload',\n        expect.objectContaining({\n          errorId: expect.any(String),\n          errorType: 'Error',\n        })\n      );\n    });\n\n    expect(mockReload).toHaveBeenCalled();\n  });\n\n  it('should reset error boundary when retry is pressed', async () => {\n    const { getByText, rerender } = render(\n      <ErrorBoundary>\n        <ThrowError shouldThrow={false} />\n      </ErrorBoundary>\n    );\n\n    // Trigger error\n    rerender(\n      <ErrorBoundary>\n        <ThrowError shouldThrow={true} />\n      </ErrorBoundary>\n    );\n\n    await waitFor(() => {\n      expect(getByText('Ops! Algo deu errado')).toBeTruthy();\n    });\n\n    // Press retry button\n    fireEvent.press(getByText('Tentar Novamente'));\n\n    // Should reset and show normal content\n    rerender(\n      <ErrorBoundary>\n        <ThrowError shouldThrow={false} />\n      </ErrorBoundary>\n    );\n\n    await waitFor(() => {\n      expect(getByText('No error')).toBeTruthy();\n    });\n  });\n\n  it('should reset on props change when resetOnPropsChange is true', async () => {\n    const { getByText, rerender } = render(\n      <ErrorBoundary resetOnPropsChange resetKeys={['key1']}>\n        <ThrowError shouldThrow={false} />\n      </ErrorBoundary>\n    );\n\n    // Trigger error\n    rerender(\n      <ErrorBoundary resetOnPropsChange resetKeys={['key1']}>\n        <ThrowError shouldThrow={true} />\n      </ErrorBoundary>\n    );\n\n    await waitFor(() => {\n      expect(getByText('Ops! Algo deu errado')).toBeTruthy();\n    });\n\n    // Change reset key\n    rerender(\n      <ErrorBoundary resetOnPropsChange resetKeys={['key2']}>\n        <ThrowError shouldThrow={false} />\n      </ErrorBoundary>\n    );\n\n    await waitFor(() => {\n      expect(getByText('No error')).toBeTruthy();\n    });\n  });\n\n  it('should show error details in development mode', async () => {\n    const originalDev = __DEV__;\n    (global as any).__DEV__ = true;\n\n    const { getByText, rerender } = render(\n      <ErrorBoundary>\n        <ThrowError shouldThrow={false} />\n      </ErrorBoundary>\n    );\n\n    rerender(\n      <ErrorBoundary>\n        <ThrowError shouldThrow={true} errorMessage=\"Dev mode error\" />\n      </ErrorBoundary>\n    );\n\n    await waitFor(() => {\n      expect(getByText('Detalhes do erro:')).toBeTruthy();\n      expect(getByText('Dev mode error')).toBeTruthy();\n    });\n\n    (global as any).__DEV__ = originalDev;\n  });\n\n  it('should handle logging errors gracefully', async () => {\n    // Mock analytics service to throw error\n    (AnalyticsService.trackError as jest.Mock).mockImplementation(() => {\n      throw new Error('Analytics error');\n    });\n\n    const { rerender } = render(\n      <ErrorBoundary>\n        <ThrowError shouldThrow={false} />\n      </ErrorBoundary>\n    );\n\n    // Should not crash when logging fails\n    expect(() => {\n      rerender(\n        <ErrorBoundary>\n          <ThrowError shouldThrow={true} />\n        </ErrorBoundary>\n      );\n    }).not.toThrow();\n  });\n});\n\ndescribe('useErrorHandler', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  it('should handle manual errors', () => {\n    const { getByText } = render(\n      <ComponentWithErrorHandler shouldTriggerError={true} />\n    );\n\n    fireEvent.press(getByText('Trigger Error'));\n\n    expect(AnalyticsService.trackError).toHaveBeenCalledWith(\n      'Error',\n      'Manual error',\n      expect.objectContaining({\n        stack: expect.any(String),\n        manual: true,\n        context: 'test',\n      })\n    );\n\n    expect(ErrorService.logError).toHaveBeenCalledWith(\n      expect.objectContaining({\n        type: 'manual_error',\n        message: 'Manual error',\n        manual: true,\n        context: 'test',\n      })\n    );\n  });\n\n  it('should handle errors without additional context', () => {\n    const TestComponent = () => {\n      const { handleError } = useErrorHandler();\n      \n      const triggerError = () => {\n        handleError(new Error('Simple error'));\n      };\n\n      return <Text onPress={triggerError}>Trigger Simple Error</Text>;\n    };\n\n    const { getByText } = render(<TestComponent />);\n\n    fireEvent.press(getByText('Trigger Simple Error'));\n\n    expect(AnalyticsService.trackError).toHaveBeenCalledWith(\n      'Error',\n      'Simple error',\n      expect.objectContaining({\n        stack: expect.any(String),\n        manual: true,\n      })\n    );\n  });\n});\n\n// Integration tests\ndescribe('ErrorBoundary Integration', () => {\n  it('should work with nested error boundaries', async () => {\n    const { getByText, rerender } = render(\n      <ErrorBoundary fallback={<Text>Outer error</Text>}>\n        <ErrorBoundary fallback={<Text>Inner error</Text>}>\n          <ThrowError shouldThrow={false} />\n        </ErrorBoundary>\n      </ErrorBoundary>\n    );\n\n    expect(getByText('No error')).toBeTruthy();\n\n    // Trigger error - should be caught by inner boundary\n    rerender(\n      <ErrorBoundary fallback={<Text>Outer error</Text>}>\n        <ErrorBoundary fallback={<Text>Inner error</Text>}>\n          <ThrowError shouldThrow={true} />\n        </ErrorBoundary>\n      </ErrorBoundary>\n    );\n\n    await waitFor(() => {\n      expect(getByText('Inner error')).toBeTruthy();\n    });\n  });\n\n  it('should handle async errors in useEffect', async () => {\n    const AsyncErrorComponent = ({ shouldThrow = false }) => {\n      const { handleError } = useErrorHandler();\n\n      React.useEffect(() => {\n        if (shouldThrow) {\n          // Simulate async error\n          setTimeout(() => {\n            handleError(new Error('Async error'));\n          }, 0);\n        }\n      }, [shouldThrow, handleError]);\n\n      return <Text>Async component</Text>;\n    };\n\n    const { rerender } = render(\n      <ErrorBoundary>\n        <AsyncErrorComponent shouldThrow={false} />\n      </ErrorBoundary>\n    );\n\n    rerender(\n      <ErrorBoundary>\n        <AsyncErrorComponent shouldThrow={true} />\n      </ErrorBoundary>\n    );\n\n    await waitFor(() => {\n      expect(AnalyticsService.trackError).toHaveBeenCalledWith(\n        'Error',\n        'Async error',\n        expect.any(Object)\n      );\n    });\n  });\n});"} 
ToolResult: SUCCESS - Created the golf - mk3 - app / __tests__ / components / ErrorBoundary.test.tsx file. 
< function_calls >
    <invoke name="fsWrite">
        <parameter name="path">golf-mk3-app/jest.config.js