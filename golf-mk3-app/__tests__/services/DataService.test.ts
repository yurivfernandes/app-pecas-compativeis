import { DataService } from '../../src/services/DataService';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\n\n// Mock AsyncStorage\njest.mock('@react-native-async-storage/async-storage', () => ({\n  getItem: jest.fn(),\n  setItem: jest.fn(),\n  removeItem: jest.fn(),\n  clear: jest.fn(),\n}));\n\n// Mock data\nconst mockPecasData = {\n  pecas: [\n    {\n      id: 'test_peca',\n      nome: 'Peça Teste',\n      categoria: 'Motor',\n      modelo_golf: ['GTI'],\n      compativel_com: [{\n        veiculo: 'Teste Car',\n        modelo: 'Test Model',\n        observacoes: 'Test observation'\n      }],\n      preco_original: 'R$ 100,00',\n      preco_compativel: 'R$ 50,00'\n    }\n  ],\n  categorias: ['Motor'],\n  modelos_golf: ['GTI']\n};\n\nconst mockCoresData = {\n  cores: [\n    {\n      codigo: 'TEST1',\n      nome: 'Test Color',\n      ano: '1994',\n      tipo: 'Solid',\n      imagem_url: 'http://test.com/image.jpg',\n      disponivel: true\n    }\n  ],\n  tipos: ['Solid'],\n  anos: ['1994']\n};\n\nconst mockFusiveisData = {\n  fusiveis: [\n    {\n      id: 'f1',\n      posicao: '1',\n      amperagem: '10A',\n      funcao: 'Test Function',\n      tipo: 'fusivel',\n      localizacao: 'caixa_principal',\n      coordenadas: { x: 50, y: 80 }\n    }\n  ],\n  localizacoes: [],\n  tipos: [],\n  amperagens: ['10A']\n};\n\n// Mock fetch\nglobal.fetch = jest.fn();\n\ndescribe('DataService', () => {\n  let dataService: DataService;\n  const mockAsyncStorage = AsyncStorage as jest.Mocked<typeof AsyncStorage>;\n  const mockFetch = fetch as jest.MockedFunction<typeof fetch>;\n\n  beforeEach(() => {\n    dataService = DataService.getInstance();\n    jest.clearAllMocks();\n  });\n\n  describe('getInstance', () => {\n    it('should return singleton instance', () => {\n      const instance1 = DataService.getInstance();\n      const instance2 = DataService.getInstance();\n      expect(instance1).toBe(instance2);\n    });\n  });\n\n  describe('loadPecas', () => {\n    it('should load pecas from cache when available', async () => {\n      mockAsyncStorage.getItem.mockResolvedValue(JSON.stringify(mockPecasData));\n      \n      const result = await dataService.loadPecas();\n      \n      expect(result).toEqual(mockPecasData);\n      expect(mockAsyncStorage.getItem).toHaveBeenCalledWith('@golf_mk3_pecas');\n    });\n\n    it('should load pecas from network when cache is empty', async () => {\n      mockAsyncStorage.getItem.mockResolvedValue(null);\n      mockFetch.mockResolvedValue({\n        ok: true,\n        json: () => Promise.resolve(mockPecasData),\n      } as Response);\n\n      const result = await dataService.loadPecas();\n\n      expect(result).toEqual(mockPecasData);\n      expect(mockAsyncStorage.setItem).toHaveBeenCalledWith(\n        '@golf_mk3_pecas',\n        JSON.stringify(mockPecasData)\n      );\n    });\n\n    it('should throw error when network request fails', async () => {\n      mockAsyncStorage.getItem.mockResolvedValue(null);\n      mockFetch.mockResolvedValue({\n        ok: false,\n        status: 404,\n      } as Response);\n\n      await expect(dataService.loadPecas()).rejects.toThrow('Failed to load pecas data');\n    });\n\n    it('should use cache when network fails', async () => {\n      const cachedData = { ...mockPecasData, cached: true };\n      mockAsyncStorage.getItem.mockResolvedValue(JSON.stringify(cachedData));\n      mockFetch.mockRejectedValue(new Error('Network error'));\n\n      const result = await dataService.loadPecas(false); // Force network request\n\n      expect(result).toEqual(cachedData);\n    });\n  });\n\n  describe('loadCores', () => {\n    it('should load cores from cache when available', async () => {\n      mockAsyncStorage.getItem.mockResolvedValue(JSON.stringify(mockCoresData));\n      \n      const result = await dataService.loadCores();\n      \n      expect(result).toEqual(mockCoresData);\n      expect(mockAsyncStorage.getItem).toHaveBeenCalledWith('@golf_mk3_cores');\n    });\n\n    it('should load cores from network when cache is empty', async () => {\n      mockAsyncStorage.getItem.mockResolvedValue(null);\n      mockFetch.mockResolvedValue({\n        ok: true,\n        json: () => Promise.resolve(mockCoresData),\n      } as Response);\n\n      const result = await dataService.loadCores();\n\n      expect(result).toEqual(mockCoresData);\n      expect(mockAsyncStorage.setItem).toHaveBeenCalledWith(\n        '@golf_mk3_cores',\n        JSON.stringify(mockCoresData)\n      );\n    });\n  });\n\n  describe('loadFusiveis', () => {\n    it('should load fusiveis from cache when available', async () => {\n      mockAsyncStorage.getItem.mockResolvedValue(JSON.stringify(mockFusiveisData));\n      \n      const result = await dataService.loadFusiveis();\n      \n      expect(result).toEqual(mockFusiveisData);\n      expect(mockAsyncStorage.getItem).toHaveBeenCalledWith('@golf_mk3_fusiveis');\n    });\n\n    it('should load fusiveis from network when cache is empty', async () => {\n      mockAsyncStorage.getItem.mockResolvedValue(null);\n      mockFetch.mockResolvedValue({\n        ok: true,\n        json: () => Promise.resolve(mockFusiveisData),\n      } as Response);\n\n      const result = await dataService.loadFusiveis();\n\n      expect(result).toEqual(mockFusiveisData);\n      expect(mockAsyncStorage.setItem).toHaveBeenCalledWith(\n        '@golf_mk3_fusiveis',\n        JSON.stringify(mockFusiveisData)\n      );\n    });\n  });\n\n  describe('searchPecas', () => {\n    beforeEach(async () => {\n      mockAsyncStorage.getItem.mockResolvedValue(JSON.stringify(mockPecasData));\n      await dataService.loadPecas();\n    });\n\n    it('should search pecas by name', async () => {\n      const results = await dataService.searchPecas('Peça Teste');\n      \n      expect(results).toHaveLength(1);\n      expect(results[0].nome).toBe('Peça Teste');\n    });\n\n    it('should search pecas by categoria', async () => {\n      const results = await dataService.searchPecas('Motor');\n      \n      expect(results).toHaveLength(1);\n      expect(results[0].categoria).toBe('Motor');\n    });\n\n    it('should return empty array for no matches', async () => {\n      const results = await dataService.searchPecas('NonExistent');\n      \n      expect(results).toHaveLength(0);\n    });\n\n    it('should be case insensitive', async () => {\n      const results = await dataService.searchPecas('peça teste');\n      \n      expect(results).toHaveLength(1);\n      expect(results[0].nome).toBe('Peça Teste');\n    });\n  });\n\n  describe('searchCores', () => {\n    beforeEach(async () => {\n      mockAsyncStorage.getItem.mockResolvedValue(JSON.stringify(mockCoresData));\n      await dataService.loadCores();\n    });\n\n    it('should search cores by codigo', async () => {\n      const results = await dataService.searchCores('TEST1');\n      \n      expect(results).toHaveLength(1);\n      expect(results[0].codigo).toBe('TEST1');\n    });\n\n    it('should search cores by name', async () => {\n      const results = await dataService.searchCores('Test Color');\n      \n      expect(results).toHaveLength(1);\n      expect(results[0].nome).toBe('Test Color');\n    });\n  });\n\n  describe('searchFusiveis', () => {\n    beforeEach(async () => {\n      mockAsyncStorage.getItem.mockResolvedValue(JSON.stringify(mockFusiveisData));\n      await dataService.loadFusiveis();\n    });\n\n    it('should search fusiveis by posicao', async () => {\n      const results = await dataService.searchFusiveis('1');\n      \n      expect(results).toHaveLength(1);\n      expect(results[0].posicao).toBe('1');\n    });\n\n    it('should search fusiveis by funcao', async () => {\n      const results = await dataService.searchFusiveis('Test Function');\n      \n      expect(results).toHaveLength(1);\n      expect(results[0].funcao).toBe('Test Function');\n    });\n  });\n\n  describe('filterPecas', () => {\n    beforeEach(async () => {\n      mockAsyncStorage.getItem.mockResolvedValue(JSON.stringify(mockPecasData));\n      await dataService.loadPecas();\n    });\n\n    it('should filter pecas by categoria', async () => {\n      const results = await dataService.filterPecas({ categoria: 'Motor' });\n      \n      expect(results).toHaveLength(1);\n      expect(results[0].categoria).toBe('Motor');\n    });\n\n    it('should filter pecas by modelo_golf', async () => {\n      const results = await dataService.filterPecas({ modelo_golf: 'GTI' });\n      \n      expect(results).toHaveLength(1);\n      expect(results[0].modelo_golf).toContain('GTI');\n    });\n\n    it('should return all pecas when no filters applied', async () => {\n      const results = await dataService.filterPecas({});\n      \n      expect(results).toHaveLength(1);\n    });\n  });\n\n  describe('filterCores', () => {\n    beforeEach(async () => {\n      mockAsyncStorage.getItem.mockResolvedValue(JSON.stringify(mockCoresData));\n      await dataService.loadCores();\n    });\n\n    it('should filter cores by tipo', async () => {\n      const results = await dataService.filterCores({ tipo: 'Solid' });\n      \n      expect(results).toHaveLength(1);\n      expect(results[0].tipo).toBe('Solid');\n    });\n\n    it('should filter cores by ano', async () => {\n      const results = await dataService.filterCores({ ano: '1994' });\n      \n      expect(results).toHaveLength(1);\n      expect(results[0].ano).toBe('1994');\n    });\n\n    it('should filter cores by disponivel', async () => {\n      const results = await dataService.filterCores({ disponivel: true });\n      \n      expect(results).toHaveLength(1);\n      expect(results[0].disponivel).toBe(true);\n    });\n  });\n\n  describe('filterFusiveis', () => {\n    beforeEach(async () => {\n      mockAsyncStorage.getItem.mockResolvedValue(JSON.stringify(mockFusiveisData));\n      await dataService.loadFusiveis();\n    });\n\n    it('should filter fusiveis by tipo', async () => {\n      const results = await dataService.filterFusiveis({ tipo: 'fusivel' });\n      \n      expect(results).toHaveLength(1);\n      expect(results[0].tipo).toBe('fusivel');\n    });\n\n    it('should filter fusiveis by localizacao', async () => {\n      const results = await dataService.filterFusiveis({ localizacao: 'caixa_principal' });\n      \n      expect(results).toHaveLength(1);\n      expect(results[0].localizacao).toBe('caixa_principal');\n    });\n\n    it('should filter fusiveis by amperagem', async () => {\n      const results = await dataService.filterFusiveis({ amperagem: '10A' });\n      \n      expect(results).toHaveLength(1);\n      expect(results[0].amperagem).toBe('10A');\n    });\n  });\n\n  describe('clearCache', () => {\n    it('should clear all cached data', async () => {\n      await dataService.clearCache();\n      \n      expect(mockAsyncStorage.removeItem).toHaveBeenCalledWith('@golf_mk3_pecas');\n      expect(mockAsyncStorage.removeItem).toHaveBeenCalledWith('@golf_mk3_cores');\n      expect(mockAsyncStorage.removeItem).toHaveBeenCalledWith('@golf_mk3_fusiveis');\n    });\n  });\n\n  describe('getCacheInfo', () => {\n    it('should return cache information', async () => {\n      const mockDate = new Date('2024-01-01').toISOString();\n      mockAsyncStorage.getItem.mockImplementation((key) => {\n        if (key.includes('_timestamp')) {\n          return Promise.resolve(mockDate);\n        }\n        return Promise.resolve(null);\n      });\n\n      const cacheInfo = await dataService.getCacheInfo();\n\n      expect(cacheInfo).toHaveProperty('pecas');\n      expect(cacheInfo).toHaveProperty('cores');\n      expect(cacheInfo).toHaveProperty('fusiveis');\n      expect(cacheInfo.pecas.lastUpdated).toBe(mockDate);\n    });\n  });\n});"} 
ToolResult: SUCCESS - Created the golf-mk3-app/__tests__/services/DataService.test.ts file. 
<function_calls>
<invoke name="fsWrite">
<parameter name="path">golf-mk3-app/__tests__/services/SearchService.test.tst { SearchService } from '../../src/services/SearchService';\n\n// Mock data for testing\nconst mockData = [\n  {\n    id: '1',\n    nome: 'Velas de Ignição',\n    categoria: 'Motor',\n    modelo_golf: ['GTI', 'GL'],\n    compativel_com: [{\n      veiculo: 'Fiat Palio',\n      modelo: '1.6 16v',\n      observacoes: 'Compatibilidade total'\n    }]\n  },\n  {\n    id: '2',\n    nome: 'Filtro de Ar',\n    categoria: 'Motor',\n    modelo_golf: ['GTI'],\n    compativel_com: [{\n      veiculo: 'VW Gol',\n      modelo: 'Bola 96',\n      observacoes: 'Encaixe perfeito'\n    }]\n  },\n  {\n    id: '3',\n    nome: 'Pastilhas de Freio',\n    categoria: 'Freios',\n    modelo_golf: ['GL', 'GLX'],\n    compativel_com: [{\n      veiculo: 'VW Santana',\n      modelo: 'Todos',\n      observacoes: 'Mesmo sistema'\n    }]\n  }\n];\n\ndescribe('SearchService', () => {\n  let searchService: SearchService;\n\n  beforeEach(() => {\n    searchService = new SearchService();\n  });\n\n  describe('fuzzySearch', () => {\n    it('should find exact matches', () => {\n      const results = searchService.fuzzySearch(mockData, 'Velas de Ignição', ['nome']);\n      \n      expect(results).toHaveLength(1);\n      expect(results[0].item.nome).toBe('Velas de Ignição');\n      expect(results[0].score).toBe(1);\n    });\n\n    it('should find partial matches', () => {\n      const results = searchService.fuzzySearch(mockData, 'Velas', ['nome']);\n      \n      expect(results).toHaveLength(1);\n      expect(results[0].item.nome).toBe('Velas de Ignição');\n      expect(results[0].score).toBeGreaterThan(0.5);\n    });\n\n    it('should be case insensitive', () => {\n      const results = searchService.fuzzySearch(mockData, 'velas de ignição', ['nome']);\n      \n      expect(results).toHaveLength(1);\n      expect(results[0].item.nome).toBe('Velas de Ignição');\n    });\n\n    it('should search in multiple fields', () => {\n      const results = searchService.fuzzySearch(mockData, 'Motor', ['nome', 'categoria']);\n      \n      expect(results).toHaveLength(2);\n      expect(results.every(r => r.item.categoria === 'Motor')).toBe(true);\n    });\n\n    it('should handle typos', () => {\n      const results = searchService.fuzzySearch(mockData, 'Velas de Ignicao', ['nome']);\n      \n      expect(results).toHaveLength(1);\n      expect(results[0].item.nome).toBe('Velas de Ignição');\n      expect(results[0].score).toBeGreaterThan(0.7);\n    });\n\n    it('should return empty array for no matches', () => {\n      const results = searchService.fuzzySearch(mockData, 'NonExistent', ['nome']);\n      \n      expect(results).toHaveLength(0);\n    });\n\n    it('should respect score threshold', () => {\n      const results = searchService.fuzzySearch(mockData, 'xyz', ['nome'], { threshold: 0.8 });\n      \n      expect(results).toHaveLength(0);\n    });\n\n    it('should limit results when specified', () => {\n      const results = searchService.fuzzySearch(mockData, 'Motor', ['categoria'], { limit: 1 });\n      \n      expect(results).toHaveLength(1);\n    });\n\n    it('should sort results by score', () => {\n      const results = searchService.fuzzySearch(mockData, 'Filtro', ['nome']);\n      \n      expect(results).toHaveLength(1);\n      expect(results[0].item.nome).toBe('Filtro de Ar');\n      \n      // Test with multiple results\n      const multiResults = searchService.fuzzySearch(mockData, 'de', ['nome']);\n      \n      if (multiResults.length > 1) {\n        for (let i = 0; i < multiResults.length - 1; i++) {\n          expect(multiResults[i].score).toBeGreaterThanOrEqual(multiResults[i + 1].score);\n        }\n      }\n    });\n  });\n\n  describe('searchInNestedFields', () => {\n    it('should search in nested arrays', () => {\n      const results = searchService.searchInNestedFields(\n        mockData,\n        'Fiat',\n        ['compativel_com.veiculo']\n      );\n      \n      expect(results).toHaveLength(1);\n      expect(results[0].compativel_com[0].veiculo).toBe('Fiat Palio');\n    });\n\n    it('should search in nested object properties', () => {\n      const results = searchService.searchInNestedFields(\n        mockData,\n        '1.6',\n        ['compativel_com.modelo']\n      );\n      \n      expect(results).toHaveLength(1);\n      expect(results[0].compativel_com[0].modelo).toBe('1.6 16v');\n    });\n\n    it('should search in multiple nested fields', () => {\n      const results = searchService.searchInNestedFields(\n        mockData,\n        'VW',\n        ['compativel_com.veiculo']\n      );\n      \n      expect(results).toHaveLength(2);\n      expect(results.every(r => \n        r.compativel_com.some(c => c.veiculo.includes('VW'))\n      )).toBe(true);\n    });\n\n    it('should handle non-existent nested fields gracefully', () => {\n      const results = searchService.searchInNestedFields(\n        mockData,\n        'test',\n        ['nonexistent.field']\n      );\n      \n      expect(results).toHaveLength(0);\n    });\n  });\n\n  describe('filterByMultipleCriteria', () => {\n    it('should filter by single criterion', () => {\n      const results = searchService.filterByMultipleCriteria(\n        mockData,\n        { categoria: 'Motor' }\n      );\n      \n      expect(results).toHaveLength(2);\n      expect(results.every(r => r.categoria === 'Motor')).toBe(true);\n    });\n\n    it('should filter by multiple criteria', () => {\n      const results = searchService.filterByMultipleCriteria(\n        mockData,\n        { \n          categoria: 'Motor',\n          modelo_golf: 'GTI'\n        }\n      );\n      \n      expect(results).toHaveLength(2);\n      expect(results.every(r => \n        r.categoria === 'Motor' && r.modelo_golf.includes('GTI')\n      )).toBe(true);\n    });\n\n    it('should handle array field filtering', () => {\n      const results = searchService.filterByMultipleCriteria(\n        mockData,\n        { modelo_golf: 'GL' }\n      );\n      \n      expect(results).toHaveLength(2);\n      expect(results.every(r => r.modelo_golf.includes('GL'))).toBe(true);\n    });\n\n    it('should return all items when no criteria provided', () => {\n      const results = searchService.filterByMultipleCriteria(mockData, {});\n      \n      expect(results).toHaveLength(3);\n    });\n\n    it('should return empty array when no matches', () => {\n      const results = searchService.filterByMultipleCriteria(\n        mockData,\n        { categoria: 'NonExistent' }\n      );\n      \n      expect(results).toHaveLength(0);\n    });\n  });\n\n  describe('highlightMatches', () => {\n    it('should highlight exact matches', () => {\n      const highlighted = searchService.highlightMatches('Velas de Ignição', 'Velas');\n      \n      expect(highlighted).toContain('<mark>');\n      expect(highlighted).toContain('</mark>');\n      expect(highlighted).toBe('<mark>Velas</mark> de Ignição');\n    });\n\n    it('should be case insensitive', () => {\n      const highlighted = searchService.highlightMatches('Velas de Ignição', 'velas');\n      \n      expect(highlighted).toBe('<mark>Velas</mark> de Ignição');\n    });\n\n    it('should highlight multiple matches', () => {\n      const highlighted = searchService.highlightMatches('Velas de Ignição de Motor', 'de');\n      \n      expect(highlighted).toBe('Velas <mark>de</mark> Ignição <mark>de</mark> Motor');\n    });\n\n    it('should return original text when no matches', () => {\n      const highlighted = searchService.highlightMatches('Velas de Ignição', 'xyz');\n      \n      expect(highlighted).toBe('Velas de Ignição');\n    });\n\n    it('should handle empty search term', () => {\n      const highlighted = searchService.highlightMatches('Velas de Ignição', '');\n      \n      expect(highlighted).toBe('Velas de Ignição');\n    });\n\n    it('should handle special regex characters', () => {\n      const highlighted = searchService.highlightMatches('Test (special) chars', '(special)');\n      \n      expect(highlighted).toBe('Test <mark>(special)</mark> chars');\n    });\n  });\n\n  describe('getSearchSuggestions', () => {\n    it('should return suggestions based on field values', () => {\n      const suggestions = searchService.getSearchSuggestions(mockData, ['categoria']);\n      \n      expect(suggestions).toContain('Motor');\n      expect(suggestions).toContain('Freios');\n      expect(suggestions).toHaveLength(2);\n    });\n\n    it('should return unique suggestions', () => {\n      const suggestions = searchService.getSearchSuggestions(mockData, ['categoria']);\n      \n      const uniqueSuggestions = [...new Set(suggestions)];\n      expect(suggestions).toEqual(uniqueSuggestions);\n    });\n\n    it('should handle array fields', () => {\n      const suggestions = searchService.getSearchSuggestions(mockData, ['modelo_golf']);\n      \n      expect(suggestions).toContain('GTI');\n      expect(suggestions).toContain('GL');\n      expect(suggestions).toContain('GLX');\n    });\n\n    it('should limit suggestions when specified', () => {\n      const suggestions = searchService.getSearchSuggestions(\n        mockData, \n        ['categoria'], \n        { limit: 1 }\n      );\n      \n      expect(suggestions).toHaveLength(1);\n    });\n\n    it('should filter suggestions by minimum length', () => {\n      const suggestions = searchService.getSearchSuggestions(\n        mockData, \n        ['categoria'], \n        { minLength: 10 }\n      );\n      \n      // 'Motor' and 'Freios' are both less than 10 characters\n      expect(suggestions).toHaveLength(0);\n    });\n  });\n\n  describe('calculateRelevanceScore', () => {\n    it('should return higher score for exact matches', () => {\n      const exactScore = searchService.calculateRelevanceScore('test', 'test');\n      const partialScore = searchService.calculateRelevanceScore('test', 'tes');\n      \n      expect(exactScore).toBeGreaterThan(partialScore);\n    });\n\n    it('should return higher score for matches at the beginning', () => {\n      const beginningScore = searchService.calculateRelevanceScore('test string', 'test');\n      const middleScore = searchService.calculateRelevanceScore('some test string', 'test');\n      \n      expect(beginningScore).toBeGreaterThan(middleScore);\n    });\n\n    it('should be case insensitive', () => {\n      const lowerScore = searchService.calculateRelevanceScore('Test String', 'test');\n      const upperScore = searchService.calculateRelevanceScore('TEST STRING', 'test');\n      \n      expect(lowerScore).toBe(upperScore);\n    });\n\n    it('should return 0 for no matches', () => {\n      const score = searchService.calculateRelevanceScore('test', 'xyz');\n      \n      expect(score).toBe(0);\n    });\n\n    it('should handle empty strings', () => {\n      const emptyTextScore = searchService.calculateRelevanceScore('', 'test');\n      const emptyQueryScore = searchService.calculateRelevanceScore('test', '');\n      \n      expect(emptyTextScore).toBe(0);\n      expect(emptyQueryScore).toBe(0);\n    });\n  });\n\n  describe('performance', () => {\n    it('should handle large datasets efficiently', () => {\n      // Create a large dataset\n      const largeData = Array.from({ length: 1000 }, (_, i) => ({\n        id: i.toString(),\n        nome: `Item ${i}`,\n        categoria: i % 2 === 0 ? 'Motor' : 'Freios',\n        modelo_golf: ['GTI'],\n        compativel_com: []\n      }));\n\n      const startTime = Date.now();\n      const results = searchService.fuzzySearch(largeData, 'Item', ['nome'], { limit: 10 });\n      const endTime = Date.now();\n\n      expect(results).toHaveLength(10);\n      expect(endTime - startTime).toBeLessThan(1000); // Should complete in less than 1 second\n    });\n  });\n});"} 
ToolResult: SUCCESS - Created the golf-mk3-app/__tests__/services/SearchService.test.ts file. 
<function_calls>
<invoke name="fsWrite">
<parameter name="path">golf-mk3-app/__tests__/components/PecaCard.test.tsxport React from 'react';\nimport { render, fireEvent, waitFor } from '@testing-library/react-native';\nimport { PecaCard } from '../../src/components/pecas/PecaCard';\nimport { AnalyticsService } from '../../src/services/AnalyticsService';\n\n// Mock AnalyticsService\njest.mock('../../src/services/AnalyticsService', () => ({\n  AnalyticsService: {\n    trackEvent: jest.fn(),\n    trackPecaView: jest.fn(),\n  },\n}));\n\n// Mock react-native-vector-icons\njest.mock('@expo/vector-icons', () => ({\n  Ionicons: 'Ionicons',\n}));\n\n// Mock responsive hook\njest.mock('../../src/hooks/useResponsive', () => ({\n  useResponsive: () => ({\n    isMobile: true,\n    isTablet: false,\n    isDesktop: false,\n    getStyle: (styles: any) => styles.mobile || {},\n  }),\n}));\n\nconst mockPeca = {\n  id: 'test_peca',\n  nome: 'Velas de Ignição',\n  categoria: 'Motor',\n  modelo_golf: ['GTI', 'GL'],\n  compativel_com: [\n    {\n      veiculo: 'Fiat Palio',\n      modelo: '1.6 16v',\n      observacoes: 'Compatibilidade total'\n    },\n    {\n      veiculo: 'VW Gol',\n      modelo: 'AP',\n      observacoes: 'Encaixe perfeito'\n    }\n  ],\n  preco_original: 'R$ 45,00',\n  preco_compativel: 'R$ 25,00'\n};\n\ndescribe('PecaCard', () => {\n  const mockOnPress = jest.fn();\n  const mockAnalytics = AnalyticsService as jest.Mocked<typeof AnalyticsService>;\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  it('should render peca information correctly', () => {\n    const { getByText } = render(\n      <PecaCard peca={mockPeca} onPress={mockOnPress} />\n    );\n\n    expect(getByText('Velas de Ignição')).toBeTruthy();\n    expect(getByText('Motor')).toBeTruthy();\n    expect(getByText('GTI, GL')).toBeTruthy();\n    expect(getByText('2 veículos compatíveis')).toBeTruthy();\n  });\n\n  it('should display price information when available', () => {\n    const { getByText } = render(\n      <PecaCard peca={mockPeca} onPress={mockOnPress} showPrice />\n    );\n\n    expect(getByText('R$ 45,00')).toBeTruthy();\n    expect(getByText('R$ 25,00')).toBeTruthy();\n  });\n\n  it('should not display price when showPrice is false', () => {\n    const { queryByText } = render(\n      <PecaCard peca={mockPeca} onPress={mockOnPress} showPrice={false} />\n    );\n\n    expect(queryByText('R$ 45,00')).toBeNull();\n    expect(queryByText('R$ 25,00')).toBeNull();\n  });\n\n  it('should handle press events correctly', async () => {\n    const { getByTestId } = render(\n      <PecaCard peca={mockPeca} onPress={mockOnPress} />\n    );\n\n    const card = getByTestId('peca-card');\n    fireEvent.press(card);\n\n    await waitFor(() => {\n      expect(mockOnPress).toHaveBeenCalledWith(mockPeca);\n    });\n  });\n\n  it('should track analytics on press', async () => {\n    const { getByTestId } = render(\n      <PecaCard peca={mockPeca} onPress={mockOnPress} />\n    );\n\n    const card = getByTestId('peca-card');\n    fireEvent.press(card);\n\n    await waitFor(() => {\n      expect(mockAnalytics.trackPecaView).toHaveBeenCalledWith(\n        mockPeca.id,\n        mockPeca.categoria\n      );\n    });\n  });\n\n  it('should display highlighted search term when provided', () => {\n    const { getByText } = render(\n      <PecaCard \n        peca={mockPeca} \n        onPress={mockOnPress} \n        searchTerm=\"Velas\"\n      />\n    );\n\n    // The highlighted text should be present\n    expect(getByText('Velas de Ignição')).toBeTruthy();\n  });\n\n  it('should show compact layout when specified', () => {\n    const { getByTestId } = render(\n      <PecaCard \n        peca={mockPeca} \n        onPress={mockOnPress} \n        layout=\"compact\"\n      />\n    );\n\n    const card = getByTestId('peca-card');\n    expect(card).toBeTruthy();\n  });\n\n  it('should show detailed layout by default', () => {\n    const { getByText } = render(\n      <PecaCard peca={mockPeca} onPress={mockOnPress} />\n    );\n\n    // In detailed layout, compatibility info should be visible\n    expect(getByText('2 veículos compatíveis')).toBeTruthy();\n  });\n\n  it('should handle empty compativel_com array', () => {\n    const pecaWithoutCompatibility = {\n      ...mockPeca,\n      compativel_com: []\n    };\n\n    const { getByText } = render(\n      <PecaCard peca={pecaWithoutCompatibility} onPress={mockOnPress} />\n    );\n\n    expect(getByText('Nenhum veículo compatível')).toBeTruthy();\n  });\n\n  it('should handle single modelo_golf', () => {\n    const pecaWithSingleModel = {\n      ...mockPeca,\n      modelo_golf: ['GTI']\n    };\n\n    const { getByText } = render(\n      <PecaCard peca={pecaWithSingleModel} onPress={mockOnPress} />\n    );\n\n    expect(getByText('GTI')).toBeTruthy();\n  });\n\n  it('should handle long peca names gracefully', () => {\n    const pecaWithLongName = {\n      ...mockPeca,\n      nome: 'Este é um nome muito longo para uma peça que deveria ser truncado adequadamente'\n    };\n\n    const { getByText } = render(\n      <PecaCard peca={pecaWithLongName} onPress={mockOnPress} />\n    );\n\n    expect(getByText(pecaWithLongName.nome)).toBeTruthy();\n  });\n\n  it('should apply custom style when provided', () => {\n    const customStyle = { backgroundColor: 'red' };\n    \n    const { getByTestId } = render(\n      <PecaCard \n        peca={mockPeca} \n        onPress={mockOnPress} \n        style={customStyle}\n      />\n    );\n\n    const card = getByTestId('peca-card');\n    expect(card.props.style).toEqual(\n      expect.arrayContaining([\n        expect.objectContaining(customStyle)\n      ])\n    );\n  });\n\n  it('should be accessible', () => {\n    const { getByTestId } = render(\n      <PecaCard peca={mockPeca} onPress={mockOnPress} />\n    );\n\n    const card = getByTestId('peca-card');\n    \n    expect(card.props.accessible).toBe(true);\n    expect(card.props.accessibilityRole).toBe('button');\n    expect(card.props.accessibilityLabel).toContain('Velas de Ignição');\n    expect(card.props.accessibilityHint).toBeTruthy();\n  });\n\n  it('should handle missing price information', () => {\n    const pecaWithoutPrice = {\n      ...mockPeca,\n      preco_original: undefined,\n      preco_compativel: undefined\n    };\n\n    const { queryByText } = render(\n      <PecaCard peca={pecaWithoutPrice} onPress={mockOnPress} showPrice />\n    );\n\n    expect(queryByText('R$')).toBeNull();\n  });\n\n  it('should show loading state when specified', () => {\n    const { getByTestId } = render(\n      <PecaCard \n        peca={mockPeca} \n        onPress={mockOnPress} \n        loading\n      />\n    );\n\n    const loadingIndicator = getByTestId('loading-indicator');\n    expect(loadingIndicator).toBeTruthy();\n  });\n\n  it('should disable interaction when loading', async () => {\n    const { getByTestId } = render(\n      <PecaCard \n        peca={mockPeca} \n        onPress={mockOnPress} \n        loading\n      />\n    );\n\n    const card = getByTestId('peca-card');\n    fireEvent.press(card);\n\n    // Should not call onPress when loading\n    expect(mockOnPress).not.toHaveBeenCalled();\n  });\n\n  it('should show favorite indicator when favorited', () => {\n    const { getByTestId } = render(\n      <PecaCard \n        peca={mockPeca} \n        onPress={mockOnPress} \n        isFavorite\n      />\n    );\n\n    const favoriteIcon = getByTestId('favorite-icon');\n    expect(favoriteIcon).toBeTruthy();\n  });\n\n  it('should handle onFavorite callback', async () => {\n    const mockOnFavorite = jest.fn();\n    \n    const { getByTestId } = render(\n      <PecaCard \n        peca={mockPeca} \n        onPress={mockOnPress} \n        onFavorite={mockOnFavorite}\n      />\n    );\n\n    const favoriteButton = getByTestId('favorite-button');\n    fireEvent.press(favoriteButton);\n\n    await waitFor(() => {\n      expect(mockOnFavorite).toHaveBeenCalledWith(mockPeca);\n    });\n  });\n\n  it('should prevent event bubbling on favorite button press', async () => {\n    const mockOnFavorite = jest.fn();\n    \n    const { getByTestId } = render(\n      <PecaCard \n        peca={mockPeca} \n        onPress={mockOnPress} \n        onFavorite={mockOnFavorite}\n      />\n    );\n\n    const favoriteButton = getByTestId('favorite-button');\n    fireEvent.press(favoriteButton);\n\n    await waitFor(() => {\n      expect(mockOnFavorite).toHaveBeenCalled();\n      expect(mockOnPress).not.toHaveBeenCalled();\n    });\n  });\n});"} 
ToolResult: SUCCESS - Created the golf-mk3-app/__tests__/components/PecaCard.test.tsx file. 
<function_calls>
<invoke name="fsWrite">
<parameter name="path">golf-mk3-app/__tests__/hooks/useSearch.test.tsderHook, act } from '@testing-library/react-hooks';\nimport { useSearch } from '../../src/hooks/useSearch';\nimport { SearchService } from '../../src/services/SearchService';\n\n// Mock SearchService\njest.mock('../../src/services/SearchService');\n\n// Mock data\nconst mockData = [\n  {\n    id: '1',\n    nome: 'Velas de Ignição',\n    categoria: 'Motor',\n    modelo_golf: ['GTI'],\n  },\n  {\n    id: '2',\n    nome: 'Filtro de Ar',\n    categoria: 'Motor',\n    modelo_golf: ['GL'],\n  },\n  {\n    id: '3',\n    nome: 'Pastilhas de Freio',\n    categoria: 'Freios',\n    modelo_golf: ['GTI'],\n  },\n];\n\nconst mockSearchResults = [\n  {\n    item: mockData[0],\n    score: 1,\n    matches: [{ field: 'nome', indices: [[0, 5]] }],\n  },\n];\n\ndescribe('useSearch', () => {\n  const mockSearchService = SearchService as jest.MockedClass<typeof SearchService>;\n  let mockSearchServiceInstance: jest.Mocked<SearchService>;\n\n  beforeEach(() => {\n    mockSearchServiceInstance = {\n      fuzzySearch: jest.fn(),\n      filterByMultipleCriteria: jest.fn(),\n      highlightMatches: jest.fn(),\n      getSearchSuggestions: jest.fn(),\n    } as any;\n\n    mockSearchService.mockImplementation(() => mockSearchServiceInstance);\n    jest.clearAllMocks();\n  });\n\n  it('should initialize with default values', () => {\n    const { result } = renderHook(() => useSearch(mockData));\n\n    expect(result.current.query).toBe('');\n    expect(result.current.results).toEqual([]);\n    expect(result.current.isSearching).toBe(false);\n    expect(result.current.filters).toEqual({});\n    expect(result.current.suggestions).toEqual([]);\n  });\n\n  it('should update query and trigger search', async () => {\n    mockSearchServiceInstance.fuzzySearch.mockReturnValue(mockSearchResults);\n\n    const { result, waitForNextUpdate } = renderHook(() => \n      useSearch(mockData, ['nome'], { debounceMs: 0 })\n    );\n\n    act(() => {\n      result.current.setQuery('Velas');\n    });\n\n    await waitForNextUpdate();\n\n    expect(result.current.query).toBe('Velas');\n    expect(result.current.results).toEqual([mockData[0]]);\n    expect(mockSearchServiceInstance.fuzzySearch).toHaveBeenCalledWith(\n      mockData,\n      'Velas',\n      ['nome'],\n      expect.any(Object)\n    );\n  });\n\n  it('should debounce search queries', async () => {\n    jest.useFakeTimers();\n    mockSearchServiceInstance.fuzzySearch.mockReturnValue(mockSearchResults);\n\n    const { result } = renderHook(() => \n      useSearch(mockData, ['nome'], { debounceMs: 300 })\n    );\n\n    act(() => {\n      result.current.setQuery('V');\n    });\n\n    act(() => {\n      result.current.setQuery('Ve');\n    });\n\n    act(() => {\n      result.current.setQuery('Vel');\n    });\n\n    // Should not have called search yet\n    expect(mockSearchServiceInstance.fuzzySearch).not.toHaveBeenCalled();\n\n    act(() => {\n      jest.advanceTimersByTime(300);\n    });\n\n    expect(mockSearchServiceInstance.fuzzySearch).toHaveBeenCalledTimes(1);\n    expect(mockSearchServiceInstance.fuzzySearch).toHaveBeenCalledWith(\n      mockData,\n      'Vel',\n      ['nome'],\n      expect.any(Object)\n    );\n\n    jest.useRealTimers();\n  });\n\n  it('should handle empty query', async () => {\n    const { result, waitForNextUpdate } = renderHook(() => \n      useSearch(mockData, ['nome'], { debounceMs: 0 })\n    );\n\n    act(() => {\n      result.current.setQuery('');\n    });\n\n    await waitForNextUpdate();\n\n    expect(result.current.results).toEqual(mockData);\n    expect(mockSearchServiceInstance.fuzzySearch).not.toHaveBeenCalled();\n  });\n\n  it('should apply filters', async () => {\n    mockSearchServiceInstance.filterByMultipleCriteria.mockReturnValue([mockData[0]]);\n\n    const { result, waitForNextUpdate } = renderHook(() => \n      useSearch(mockData, ['nome'], { debounceMs: 0 })\n    );\n\n    act(() => {\n      result.current.setFilters({ categoria: 'Motor' });\n    });\n\n    await waitForNextUpdate();\n\n    expect(result.current.filters).toEqual({ categoria: 'Motor' });\n    expect(mockSearchServiceInstance.filterByMultipleCriteria).toHaveBeenCalledWith(\n      mockData,\n      { categoria: 'Motor' }\n    );\n  });\n\n  it('should combine search and filters', async () => {\n    mockSearchServiceInstance.fuzzySearch.mockReturnValue(mockSearchResults);\n    mockSearchServiceInstance.filterByMultipleCriteria.mockReturnValue([mockData[0]]);\n\n    const { result, waitForNextUpdate } = renderHook(() => \n      useSearch(mockData, ['nome'], { debounceMs: 0 })\n    );\n\n    act(() => {\n      result.current.setQuery('Velas');\n      result.current.setFilters({ categoria: 'Motor' });\n    });\n\n    await waitForNextUpdate();\n\n    expect(mockSearchServiceInstance.fuzzySearch).toHaveBeenCalled();\n    expect(mockSearchServiceInstance.filterByMultipleCriteria).toHaveBeenCalled();\n  });\n\n  it('should generate suggestions', async () => {\n    const mockSuggestions = ['Motor', 'Freios'];\n    mockSearchServiceInstance.getSearchSuggestions.mockReturnValue(mockSuggestions);\n\n    const { result, waitForNextUpdate } = renderHook(() => \n      useSearch(mockData, ['nome'], { \n        debounceMs: 0,\n        enableSuggestions: true,\n        suggestionFields: ['categoria']\n      })\n    );\n\n    await waitForNextUpdate();\n\n    expect(result.current.suggestions).toEqual(mockSuggestions);\n    expect(mockSearchServiceInstance.getSearchSuggestions).toHaveBeenCalledWith(\n      mockData,\n      ['categoria'],\n      expect.any(Object)\n    );\n  });\n\n  it('should clear search', async () => {\n    mockSearchServiceInstance.fuzzySearch.mockReturnValue(mockSearchResults);\n\n    const { result, waitForNextUpdate } = renderHook(() => \n      useSearch(mockData, ['nome'], { debounceMs: 0 })\n    );\n\n    // Set query first\n    act(() => {\n      result.current.setQuery('Velas');\n    });\n\n    await waitForNextUpdate();\n\n    expect(result.current.query).toBe('Velas');\n    expect(result.current.results).toEqual([mockData[0]]);\n\n    // Clear search\n    act(() => {\n      result.current.clearSearch();\n    });\n\n    expect(result.current.query).toBe('');\n    expect(result.current.results).toEqual(mockData);\n    expect(result.current.filters).toEqual({});\n  });\n\n  it('should handle search errors gracefully', async () => {\n    const consoleError = jest.spyOn(console, 'error').mockImplementation();\n    mockSearchServiceInstance.fuzzySearch.mockImplementation(() => {\n      throw new Error('Search error');\n    });\n\n    const { result, waitForNextUpdate } = renderHook(() => \n      useSearch(mockData, ['nome'], { debounceMs: 0 })\n    );\n\n    act(() => {\n      result.current.setQuery('Velas');\n    });\n\n    await waitForNextUpdate();\n\n    expect(result.current.results).toEqual(mockData); // Should fallback to original data\n    expect(consoleError).toHaveBeenCalled();\n\n    consoleError.mockRestore();\n  });\n\n  it('should respect search options', async () => {\n    const searchOptions = {\n      threshold: 0.8,\n      limit: 5,\n    };\n\n    mockSearchServiceInstance.fuzzySearch.mockReturnValue(mockSearchResults);\n\n    const { result, waitForNextUpdate } = renderHook(() => \n      useSearch(mockData, ['nome'], { \n        debounceMs: 0,\n        searchOptions \n      })\n    );\n\n    act(() => {\n      result.current.setQuery('Velas');\n    });\n\n    await waitForNextUpdate();\n\n    expect(mockSearchServiceInstance.fuzzySearch).toHaveBeenCalledWith(\n      mockData,\n      'Velas',\n      ['nome'],\n      expect.objectContaining(searchOptions)\n    );\n  });\n\n  it('should update results when data changes', async () => {\n    const { result, rerender, waitForNextUpdate } = renderHook(\n      ({ data }) => useSearch(data, ['nome'], { debounceMs: 0 }),\n      { initialProps: { data: mockData } }\n    );\n\n    expect(result.current.results).toEqual(mockData);\n\n    const newData = [...mockData, {\n      id: '4',\n      nome: 'Nova Peça',\n      categoria: 'Outros',\n      modelo_golf: ['GLX'],\n    }];\n\n    rerender({ data: newData });\n    await waitForNextUpdate();\n\n    expect(result.current.results).toEqual(newData);\n  });\n\n  it('should maintain search state when data updates', async () => {\n    mockSearchServiceInstance.fuzzySearch.mockReturnValue(mockSearchResults);\n\n    const { result, rerender, waitForNextUpdate } = renderHook(\n      ({ data }) => useSearch(data, ['nome'], { debounceMs: 0 }),\n      { initialProps: { data: mockData } }\n    );\n\n    // Set a query\n    act(() => {\n      result.current.setQuery('Velas');\n    });\n\n    await waitForNextUpdate();\n\n    expect(result.current.query).toBe('Velas');\n\n    // Update data\n    const newData = [...mockData];\n    rerender({ data: newData });\n\n    // Query should be maintained\n    expect(result.current.query).toBe('Velas');\n  });\n\n  it('should handle minimum query length', async () => {\n    const { result } = renderHook(() => \n      useSearch(mockData, ['nome'], { \n        debounceMs: 0,\n        minQueryLength: 3\n      })\n    );\n\n    act(() => {\n      result.current.setQuery('Ve');\n    });\n\n    // Should not search with query less than minimum length\n    expect(mockSearchServiceInstance.fuzzySearch).not.toHaveBeenCalled();\n    expect(result.current.results).toEqual(mockData);\n\n    act(() => {\n      result.current.setQuery('Vel');\n    });\n\n    // Should search now\n    expect(mockSearchServiceInstance.fuzzySearch).toHaveBeenCalled();\n  });\n\n  it('should cleanup on unmount', () => {\n    jest.useFakeTimers();\n    \n    const { unmount } = renderHook(() => \n      useSearch(mockData, ['nome'], { debounceMs: 300 })\n    );\n\n    unmount();\n\n    // Should not throw any errors\n    act(() => {\n      jest.advanceTimersByTime(300);\n    });\n\n    jest.useRealTimers();\n  });\n});"} 
ToolResult: SUCCESS - Created the golf-mk3-app/__tests__/hooks/useSearch.test.ts file. 
<function_calls>
<invoke name="fsWrite">
<parameter name="path">golf-mk3-app/__tests__/integration/navigation.test.tsx